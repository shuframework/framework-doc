如果说，数学是思维的体操，那设计模式，就是面向对象编程思维的体操。
我学了设计模式后时常会过度设计，如何办?
作者建议，暂时现象，继续努力。
```
因为怕过度设计而不用设计模式显然是因噎废食。当你认识到自己有过度使用模式的时候，那就明你已意识到问题的存在，只有通过不断的钻研和努力，你才能突破"不识庐山真面目，只缘身在此山中"的瓶颈，达到"会当凌绝顶，一览众山小"的境界。
```



## 0. 设计模式常用组合

* 一般情况 singleton(单例) factory(工厂) builder(建造者) 这3个或几个会组合一起使用
* 代理模式(proxy) 的动态代理 是aop的基础
* 装饰模式 的典型应该是 io流的设计上
* 行为型模式应用比较广，需要多了解

责任链， 策略， iterator



##  1.相似的设计模式比较

### 1.1 单例模式与享元模式



### 1.2 装饰模式与代理模式

1. 代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能

2. 使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。（当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。）



### 1.3 状态模式、策略模式与责任链模式

  状态模式出现的根本原因是需要对自身的状态进行改变，而责任链模式是对一个事件的处理，策略模式是封装一组但只有一个生效。



**状态其本质是：一个类对不同状态的多种不同响应**

  状态的判断逻辑转到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。让**各个状态对象自己知道其下一个处理的对象是谁**！即在状态子类编译时在代码上就设定好了！



**职责链的本质是：不同的类对同一个问题的反应**

责任链实现的关键有：
（1）需要责任链上一系列的处理类实现统一的接口
（2）需要有管理器来指定所有处理类的拦截处理顺序
（3）每一个责任链上的处理对类都明确自己可以处理的命令，也知道如何将自己不能处理的命令传递给该链中的下一个处理对象
（4）该模式还描述了往该处理链的末尾添加新的处理对象的方法
--------------------- 
作者：我想说的CSDN 
来源：CSDN 
原文：https://blog.csdn.net/wang2963973852/article/details/79483790 
版权声明：本文为博主原创文章，转载请附上博文链接！

# 一、创建型模式

## 1. 单例模式

###    1.1 定义（应用场景）

保证一个类仅有一个实例，并提供一个访问它的方法（全局访问点）


###    1.2 开发中的常见场景

* 读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
* 网站的计数器，一般也是采用单例模式实现，否则难以同步。
* 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
* 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
* 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
* 在servlet编程中，每个Servlet也是单例
* 在spring MVC框架/struts1框架中，控制器对象也是单例



###    1.3 常见的单例实现方式

实现方式的优劣，3个维度评估：线程安全、高性能、懒加载。

###   # 1. 饿汉式（hungry）

```
不管你用的用不上，一开始就建立这个单例对象，线程安全，效率高；
缺点是 不用时也初始化对象了即没有懒加载。
```

###   # 2. 懒汉式（lazy）

```
真正用到的时候才去建这个单例对象，延迟加载，资源利用高；
缺点是 并发调用效率低因为加了同步锁的关系。
```

###   # 3. 静态内部类（hungry+内部类实现lazy）

```
真正用到的时候才去建这个单例对象，延迟加载，资源利用高，且并发调用效率高；
缺点是 没什么缺点
```
###   # 4. 枚举方式（enum）

不太推荐使用，推荐方式3



## 2. 工厂方法

###    2.1 应用场景




###    2.2 开发中的常见场景



## 3. 抽象工厂

###    3.1 定义（应用场景）

用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）

###    3.2 开发中的常见场景



## 工厂家族

* spring中IOC容器创建管理bean对象

### 1. 简单工厂模式（静态工厂模式）

实现简单 也比较常用

违反了开闭原则，扩展时会不停修改 工厂类，一般是可以接收这样的改动

### 2. 方法工厂模式

简单工厂的细化，有了更好的扩展性，但是增加了复杂度，实际开发中一般这样使用

### 3\. 抽象工厂模式

用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）





## 4. 建造者模式 builder

###    4.1 定义（应用场景）

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。


 ###    4.2 开发中的常见场景

* SQL中的PreparedStatement 
* JDOM中，DomBuilder



## 5. 原型模式（克隆模式）

 ###    5.1 定义（应用场景）

原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。

 ###    5.2 开发中的常见场景

* spring中bean的创建实际就是两种：单例模式+原型模式。



# 二、结构型模式

## 6. 适配器模式 adapter

 ###    6.1 定义（应用场景）

 使原本由于接口不兼容不能一起工作的类可以一起工作，在系统设计时 这个模式一开始推荐不使用，等版本升级过程中遇到了不可修改的几个相似的接口或类时才考虑使用。

（如果能事先预防接口的问题，就能避免问题；在有小的接口不统一问题发生时，及时重构，问题不至于扩大；只有碰到无法改变原有设计和代码的情况时，才考虑适配）

 ###    6.2 开发中的常见场景

* io流 的转换流。

###    6.3 实现

类适配器模式和 对象适配器模式，由于Java不能多继承，所以考虑 对象适配器模式，将2个类似功能的接口 通过一个中间接口进行匹配达到适配的目的。




## 7. 代理模式（主要是动态代理）proxy

 ###    7.1 定义（应用场景）

 

 ###    7.2 开发中的常见场景

* mybatis中实现拦截器插件。
* spring中AOP的实现
* RMI远程方法调用

###    7.3 基于jdk实现动态代理（注意原理）

https://blog.csdn.net/xiaokang123456kao/article/details/77679848

就是动态生成了class文件，基于接口的原因是底层已经继承了Proxy类，所以只能基于接口来实现，而且面向接口编程也是推崇的方式 



## 8. 桥接模式（桥梁模式）bridge

 ###    8.1 定义（应用场景）

多个变化纬度 用多层继承来实现扩展性不好，将抽象部分与它的实现部分分离，使它们都可以独立地变化。

 ###    8.2 开发中的常见场景

* 银行日志管理：
	* 格式分类：操作日志、交易日志、异常日志
	* 距离分类：本地记录日志、异地记录日志
* 人力资源系统中的奖金计算模块：
	* 奖金分类：个人奖金、团体奖金、激励奖金。
	* 部门分类：人事部门、销售部门、研发部门。
* OA系统中的消息处理：
	* 业务类型：普通消息、加急消息、特急消息
	* 发送消息方式：系统内消息、手机短信、邮件

现在的微服务 大多是接口定义与实现分离




## 9. 组合模式

 ###    9.1 定义（应用场景）

 

 ###    9.2 开发中的常见场景





## 10. 装饰模式 decorator

###    10.1 定义（应用场景）



###    10.2 开发中的常见场景






## 11.外观模式（门面模式） facade

###    11.1 定义（应用场景）

为子系统中的一组接口提供一个一致的界面，外部调用简单，不用接触太多对象。

###    11.2 开发中的常见场景

* 将多个服务 整合为一个接口，提供服务（经典的3层思想就体现了门面模式）
* 对于复杂难以维护的老系统，直接去改或去扩展都可能产生很多问题，分两个小组，一个开发Facade与老系统的交互，另一个只要了解Facade的接口，直接开发新系统调用这些接口即可，确实可以减少很多不必要的麻烦。



## 12. 享元模式 flyweight

###    12.1 定义（应用场景）



###    12.2 开发中的常见场景

* 线程池，数据连接池

一般缓存的对象使用map来接收



# 三、行为型模式


## 13.责任链模式 chain of responsibility

###    13.1 定义（应用场景）



###    13.2 开发中的常见场景

* java中异常处理机制
* 过滤器的链式处理

注意有个最后的处理类来终结极端情况，否则会出现极端情况没被处理。




## 14. 命令模式 command

###    14.1 定义（应用场景）



###    14.2 开发中的常见场景





## 15.解释器模式 interpreter

###    15.1 定义（应用场景）

不常用的设计模式，当我们需要开发一种新的语言时，可以考虑使用解释器模式

###    15.2 开发中的常见场景

* sql语法的解释器



## 16. 迭代器模式 iterator

###    16.1 定义（应用场景）

分离了集合对象的遍历行为，抽象出一个迭代器类来负责。

这样可以做到不暴露集合的内部结构，又可以让外部代码透明地访问集合内部的数据。

###    16.2 开发中的常见场景

jdk内置的迭代器，foreach/Iterator




## 17.中介者模式 mediator

###    17.1 定义（应用场景）

将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接使得对象间耦合度高，降低了复用性，这时需要一个中间者将网状结构变成星形结构（每个具体对象不再通过直接的联系与另一个对象发生相互作用）。

###    17.2 开发中的常见场景

* mvc中的c 有m和v

注意：具体对象都认识中介者，即具体对象都有中介者对象，中介者需要通知具体对象，所以方法是有具体对象的



## 18. 备忘录模式 memento

###    18.1 定义（应用场景）



###    18.2 开发中的常见场景

- 棋类游戏中的 悔棋
- 数据库中的事务管理中的回滚



## 19. 观察者模式 observer

观察者模式又叫 发布-订阅（publish/subscribe）模式

###    19.1 定义（应用场景）

一个对象的改变需要同时改变其他对象的时候，而且不知道具体有多少对象待改变时，

###    19.2 开发中的常见场景

* 委派事件模型（监听器）
* 邮件订阅
* 广播机制





jdk默认提供了 java.util.Observable（通知者）和 java.util.Observer（观察者）

为什么 通知者是类，观察者是接口？

因为观察者的具体实现会根据需求来变化，通知者的操作基本一样





## 20. 状态模式 state

###    20.1 定义（应用场景）

当一个对象的状态转换的判断过于复杂时，把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。如果状态判断逻辑简单就没必要使用该模式。

###    20.2 开发中的常见场景

* 状态流转，审批功能	



## 21. 策略模式 strategy

###    21.1  定义（应用场景）

针对一组算法或逻辑，将每一个算法或逻辑封装到具有共同接口的独立的类中，从而使得它们之间可以相互替换。策略模式使得算法或逻辑可以在不影响到客户端的情况下发生变化。

策略模式的出现很好地诠释了开闭原则，有效地减少了分支语句。

###    21.2 开发中的常见场景





## 22. 模板方法模式 template

###    22.1 定义（应用场景）



###    22.2 开发中的常见场景






## 23. 访问者模式 visitor

###    23.1 定义（应用场景）



###    23.2 开发中的常见场景



