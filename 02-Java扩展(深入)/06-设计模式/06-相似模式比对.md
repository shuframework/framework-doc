## 1. 外观模式和中介者模式

外观模式是结构型，中介者模式是行为型

#### 外观模式

1. 封装的是单向的交互，从客户端访问系统的调用
2. 子模块不知道外观类的存在，外观类里一般是组合调用实现功能
3. 实现解耦的方式：简化客户端的调用

#### 中介者模式

1. 用来封装多个对象之间相互的交互，多用在系统内部的多个模块之间

2. 具体对象都有中介者对象，中介者对象里是需要实现具体的交互功能

3. 实现解耦的方式：把耦合关系全部都放在中介者中实现



## 2. 适配器模式与装饰模式

2种都是使用对象组合，都可以在调转组合对象功能前后进行一些附加处理。

不同：适配器适配后是需要改变接口的，如果不改变接口就没有必要适配；装饰模式是不改变接口的，无论多少层都是一个接口。

**这2个模式与代理模式组合使用可以获得更大的灵活性**



## 3. 装饰模式与代理模式

1. 代理模式中，代理类对被代理的对象有控制权，决定其执行或者不执行。而装饰模式中，装饰类对代理对象没有控制权，只能为其增加一层装饰，以加强被装饰对象的功能
2. 使用代理模式，代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。（当我们使用装饰器模 式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。）


## 4. 装饰模式与模板方法模式

装饰模式可以模拟实现模板方法的功能，但是仅仅只是模仿功能而已，两个模式的设计目的、原本的





单例模式与享元模式



状态模式、策略模式与责任链模式

 状态模式出现的根本原因是需要对自身的状态进行改变，而责任链模式是对一个事件的处理，策略模式是封装一组但只有一个生效。



**状态其本质是：一个类对不同状态的多种不同响应**

  状态的判断逻辑转到表现不同状态的一系列类当中，可以把复杂的判断逻辑简化。让**各个状态对象自己知道其下一个处理的对象是谁**！即在状态子类编译时在代码上就设定好了！



**职责链的本质是：不同的类对同一个问题的反应**

责任链实现的关键有：
（1）需要责任链上一系列的处理类实现统一的接口
（2）需要有管理器来指定所有处理类的拦截处理顺序
（3）每一个责任链上的处理对类都明确自己可以处理的命令，也知道如何将自己不能处理的命令传递给该链中的下一个处理对象

